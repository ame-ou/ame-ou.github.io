<feed xmlns="http://www.w3.org/2005/Atom"> <id>/</id><title>Rick's Blog</title><subtitle>My personal blog, learning notes.</subtitle> <updated>2022-02-09T16:04:18+08:00</updated> <author> <name>Rick</name> <uri>/</uri> </author><link rel="self" type="application/atom+xml" href="/feed.xml"/><link rel="alternate" type="text/html" hreflang="zh-CN" href="/"/> <generator uri="https://jekyllrb.com/" version="4.2.1">Jekyll</generator> <rights> © 2022 Rick </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>原型链</title><link href="/posts/prototype-chain/" rel="alternate" type="text/html" title="原型链" /><published>2021-09-08T08:00:00+08:00</published> <updated>2021-09-08T08:00:00+08:00</updated> <id>/posts/prototype-chain/</id> <content src="/posts/prototype-chain/" /> <author> <name>Rick</name> </author> <category term="Tech" /> <summary> 原型继承 JavaScript 对象有一个指向一个原型对象的链。当试图访问一个对象的属性时，它不仅在该对象上搜寻，还会搜寻该对象的原型，以及该对象原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾 遵循 ECMAScript 标准，[[Prototype]] 符号用于指向对象原型。从 ECMAScript 6 开始，[[Prototype]] 可以通过 Object.getPrototypeOf() 和 Object.setPrototypeOf() 访问器来访问。这个等同于 JavaScript 的非标准但许多浏览器实现的属性 __proto__ 属性 每个构造函数都有一个 prototype 属性，这个属性指向一个对象，也就是原型对象 原型对象默认拥有一个 constructor 属性，指向它的构造函数 每个对象有一个隐藏的 __pr... </summary> </entry> <entry><title>事件循环</title><link href="/posts/event-loop/" rel="alternate" type="text/html" title="事件循环" /><published>2021-07-23T08:00:00+08:00</published> <updated>2021-07-23T08:00:00+08:00</updated> <id>/posts/event-loop/</id> <content src="/posts/event-loop/" /> <author> <name>Rick</name> </author> <category term="Tech" /> <summary> 任务队列 在事件循环中，每进行一次循环操作称为 tick task 分为两大类, 分别是 Macro Task （宏任务）和 Micro Task（微任务）, 并且每个宏任务结束后, 都要清空所有的微任务 在此次 tick 中选择最先进入队列的任务( oldest task )，如果有则执行(一次)， 执行过程中如果遇到微任务，就将它添加到微任务的任务队列中 检查是否存在 Microtasks ，如果存在则不停地执行，直至清空 Microtask Queue GUI 线程接管渲染 主线程重复执行上述步骤 宏任务主要包含：script( 整体代码)、setTimeout、setInterval、I/O、UI 交互事件、postMessage、MessageChannel、setImmediate(Node.js 环境) 微任务主要包含：Promise、Mu... </summary> </entry> <entry><title>前端基础</title><link href="/posts/frontend-basis/" rel="alternate" type="text/html" title="前端基础" /><published>2021-05-06T09:30:00+08:00</published> <updated>2021-06-03T13:45:30+08:00</updated> <id>/posts/frontend-basis/</id> <content src="/posts/frontend-basis/" /> <author> <name>Rick</name> </author> <category term="Tech" /> <summary> script 标签 直接写在 html 中 script 标签中的 js 代码会阻塞整个页面，包括 html 结构中位于其上面的内容 &amp;lt;script src="..."&amp;gt;&amp;lt;/script&amp;gt; 不会阻塞他之前内容的渲染，但等他下载执行完后他后面的内容才会渲染 异步创建 script 不会阻塞页面渲染 script 标签 onload 在 js 文件加载并执行完毕后调用。 webpack 将多个符合 CommonJS 规范的模块打包成一个 js 文件，供浏览器执行。异步加载可通过动态创建 script 标签实现 Time new Date().toJSON(); // 2018-08-01T07:25:06.595Z Error async 立即执行函数捕获内部错误 (async () =&amp;gt; { throw "an error"; }... </summary> </entry> <entry><title>一些概念</title><link href="/posts/concepts/" rel="alternate" type="text/html" title="一些概念" /><published>2021-04-21T12:30:00+08:00</published> <updated>2021-09-04T08:14:10+08:00</updated> <id>/posts/concepts/</id> <content src="/posts/concepts/" /> <author> <name>Rick</name> </author> <category term="Tech" /> <summary> 阻塞/非阻塞 同步/异步 阻塞：线程在执行操作时不能执行其他操作 非阻塞：线程在执行操作时可执行其他操作 同步：调用等待返回结果，不可执行其他操作 异步：调用者直接返回，可执行其他操作 面向对象/函数式 面向对象编程(OO)通过封装变化使得代码更易理解 函数式编程(FP)通过最小化变化使得代码更易理解 纯函数 仅取决于提供的输入，而不依赖于任何在函数求值期间或调用间隔时可能变化的隐藏状态和外部状态。 不会造成超出其作用域的变化，例如修改全局对象或引用传递的参数。 Tree-Shaking Tree-Shaking 只对 import 语句导入产生作用，对于 CommonJS 的 require 函数导入方式不产生作用，因为 Tree-Shaking 的工作方式是对代码进行静态分析，import 只能出现在代码的第一层，不能出现在 if 分支中... </summary> </entry> <entry><title>代码风格</title><link href="/posts/code-style/" rel="alternate" type="text/html" title="代码风格" /><published>2021-04-18T22:00:00+08:00</published> <updated>2022-02-09T16:00:18+08:00</updated> <id>/posts/code-style/</id> <content src="/posts/code-style/" /> <author> <name>Rick</name> </author> <category term="Tech" /> <summary> JavaScript 语句后应该加分号么 真正会导致上下行解析出问题的 token 有 5 个：括号、方括号、正则开头的斜杠、加号、减号(+ - / ( [)，实际代码几乎没有正则，加号，减号作为行首的情况，所以总结下来：一行开头是括号或者方括号的时候在行首加上分号。 script 标签能否放到 body 之后 Google 并没有把 &amp;lt;script&amp;gt; 插入在 &amp;lt;/body&amp;gt; 之后，而只是没有写 &amp;lt;/body&amp;gt; 和 &amp;lt;/html&amp;gt; 闭合标签。这样做是符合标准的，不仅是 HTML5 标准，从第一个 HTML 正式标准 HTML 2.0 开始，这样做都是允许的，在 &amp;lt;/body&amp;gt; 之后插入其他元素，从 HTML 2.0 起就是不合标准的。 按照 HTML5 标准中的 HTML 语法规则，如果在 &amp;lt;/body&amp;gt;... </summary> </entry> </feed>
